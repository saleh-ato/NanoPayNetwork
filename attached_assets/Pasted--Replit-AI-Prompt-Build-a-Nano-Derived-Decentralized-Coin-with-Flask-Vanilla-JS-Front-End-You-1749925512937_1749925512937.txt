# Replit AI Prompt: Build a Nano-Derived Decentralized Coin with Flask + Vanilla JS Front-End

You are an expert blockchain engineer and full-stack Python/Flask developer. Your task is to generate a **complete**, **production-grade** project scaffold on Replit that implements a decentralized cryptocurrency strongly inspired by Banano/Nano/DogeNano. Follow these requirements precisely:

---  
## 1. Project Structure & Tooling  
1. Use **Python 3.10+** and **Flask** for the backend API and node logic.  
2. Organize code in modular packages:  
   - `/node` – P2P networking, consensus, ledger storage  
   - `/wallet` – key management, address generation, transaction signing  
   - `/api` – REST/RPC endpoints for external clients/exchanges  
   - `/mempool` – pending transactions queue  
   - `/utils` – common helpers (encoding, PoW hashing)  
3. Provide a **Dockerfile** and `replit.nix` or `requirements.txt` for easy deployment.  
4. Include **unit tests** (pytest) for core modules: PoW, transaction validation, wallet operations.  

## 2. Consensus & Ledger  
1. Implement a **block-lattice** structure like Nano:  
   - Each account has its own chain.  
   - No global blocks; each transaction is a block in sender’s and receiver’s chains.  
2. Implement **lightweight Proof-of-Work** for spam protection.  
3. Design a **persistent ledger** using SQLite (configurable for PostgreSQL later).  
4. Provide synchronization logic:  
   - Peer discovery (hardcoded bootstrap nodes + simple gossip)  
   - Handshake, chain reconciliation, block propagation  

## 3. Wallet & Key Management  
1. Generate **ed25519** keypairs.  
2. Derive human-readable addresses prefixed `ban_` (or custom prefix).  
3. Implement local **balance calculation** by replaying the account chain.  
4. Provide CLI scripts to:  
   - `create_wallet.py` → new seed / private key  
   - `send_funds.py` → build & broadcast a transaction  

## 4. REST/RPC API Endpoints  
Create a Flask blueprint `/api/v1` with JSON RPC endpoints:  
- **GET /balance/<address>** → current balance  
- **POST /send** → `{ “from”: “…”, “to”: “…”, “amount”: X }`  
- **GET /history/<address>?limit=`N`** → recent transactions  
- **POST /pow** → generate PoW for a given block hash  
- **GET /peers** → list connected peers  

Ensure all endpoints have input validation, error codes, and rate-limiting headers.

## 5. Front-End (HTML/CSS/JS + Bootstrap + optional jQuery)  
1. Single-page dashboard:  
   - **Create/Import Wallet** (seed phrase input)  
   - **Display Balance & Address** (with QR code)  
   - **Transaction Form**: recipient, amount, submit  
   - **Recent Transactions** table with status badges  
2. Use **Bootstrap 5** for responsive layout.  
3. Use **Vanilla JS** or **jQuery** for AJAX calls to `/api/v1`.  
4. Implement real-time updates: poll balance & transactions every 10 seconds.  
5. Provide a **dark/light theme** toggle (CSS only).  

## 6. Exchange-Ready & Monetization Hooks  
1. Stubbed module `/exchange_adapter` to integrate with third-party exchanges:  
   - Define a standard `OrderBookClient` interface  
   - Mock implementation for a sample exchange REST API  
2. Expose secure API key management in the Flask admin UI.  
3. Document how to add KYC, deposit/withdraw callbacks, and trading pairs.  
4. Include a **monetization README** section:  
   - How to list coin on centralized exchanges (basic steps)  
   - How to integrate affiliate/referral links in the front-end  

## 7. Documentation & Developer Experience  
1. Auto-generate OpenAPI (Swagger) docs for all endpoints.  
2. Provide a comprehensive `README.md` covering:  
   - Project overview & architecture diagram  
   - Setup steps on Replit & locally  
   - How to run tests and lint (flake8)  
   - How to build Docker image and deploy  
3. Include code comments, type hints, and a CONTRIBUTING guide.

---  
**Deliverable:** A fully scaffolded Replit project that, when run, spins up a Flask node, serves the front-end dashboard, and begins P2P discovery. All code must be commit-ready, modular, and production-oriented.

Now generate all necessary files (`app.py`, packages, static assets, Dockerfile, tests, docs) in one cohesive output.  
